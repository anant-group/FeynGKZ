(* ::Package:: *)

(* ::Title:: *)
(*FeynGKZ.wl*)


(* ::Subtitle:: *)
(*a Mathematica package for solving Feynman Integrals using GKZ hypergeometric systems*)


(* ::Text:: *)
(*B. Ananthanarayan, Sumit Banik, Souvik Bera, Sudeepan Datta*)


(* ::Section:: *)
(*Package initiation*)


SetOptions[EvaluationNotebook[],  CommonDefaultFormatTypes -> {"Output" -> StandardForm}];
BeginPackage["FeynGKZ`"];
Block[{Print},Get["AMBREv2.1.1.m"]//Quiet]; 
Block[{Print},Get["Olsson.wl"]//Quiet];
LastUpdate="\!\(\*SuperscriptBox[\(2\), \(nd\)]\) November, 2022";


(* ::Section::Closed:: *)
(*Author credits and loading dependencies*)


If[$VersionNumber<12.1, Print[Style["Mathematica version incompatible, please upgrade to version 12.1 or later",Red]]; Abort[];]


If[$VersionNumber>=12.1,Print[Style["FeynGKZ 1.0",Blue,14,FontFamily->"Courier",Bold],Style[" - a Mathematica package for solving Feynman Integrals using GKZ hypergeometric systems",Blue,14,FontFamily->"Courier"]];
Print[Style["Authors: ",Black,Bold],Style[" B. Ananthanarayan, Sumit Banik, Souvik Bera, Sudeepan Datta",Brown,Bold,12.5]];
Print[Style["Last updated: ",Black,Bold], LastUpdate];]


(* ::Section::Closed:: *)
(*Global Variables*)


Global`FeynGKZPath::usage="Set this variable such that it points to the directory 
containing \"FeynGKZ.wl\" and its dependencies \"AMBREv2.1.1.m\" and \"Olsson.wl\".

Note: the path must be passed as a string.

By default, it points to \"NotebookDirectory[]\".";


Global`PolyMakePath::usage="Set this variable such that it points to the directory 
containing the \"polymake\" executable.

Note: the path must be passed as a string.

By default, it points to \"/usr/bin\".";


Global`TOPCOMPath::usage="Set this variable such that it points to the directory 
containing the \"points2triangs\" executable from TOPCOM.

Note: the path must be passed as a string.

By default, it points to \"/usr/local/bin\".";


Dim::usage="Space-time dimension of the Feynman integral.";


n::"usage"="Summation indices.";


\[ScriptZ]::"usage"="Generic coefficients of the toric G-polynomial.";


(* ::Section:: *)
(*External Modules Usage of Triangulation Method*)


FindAMatrix::usage="FindAMatrix[{MomentumRep, LoopMomenta, InvariantList, Dim, Prefactor}]
or,
FindAMatrix[{{U, F, PropagatorPowers}, LoopNumber, InvariantList, Dim,
Prefactor}]

Below, we provide details about the input arguments for FindAMatrix.

   \[Bullet] MomentumRep: A list containing information about all the propagators in the Feynman inte-
     gral. It consists of multiple sub-lists, each of which has the following pattern:
     {Propagator-Momentum, Propagator-Mass, Propagator-Power}.
   \[Bullet] U: The first Symanzik polynomial corresponding to the given Feynman integral.
   \[Bullet] F: The second Symanzik polynomial corresponding to the given Feynman integral.
   \[Bullet] PropagatorPowers: A list containing all the powers of the propagators of the Feynman
     integral.
   \[Bullet] LoopMomenta: A list containing the loop-momenta for the given Feynman integral.
   \[Bullet] LoopNumber: The number of loops appearing in the given Feynman integral. It must be an
     positive integer.
   \[Bullet] InvariantList: A list of kinematic substitutions.
   \[Bullet] Dim: the space-time dimension.
   \[Bullet] Prefactor: An overall factor that is independent of the loop-momenta.
   \[Bullet] Options:
       \[Dash] UseMB: This option accepts a boolean value. Its default value is False. When set True,
       FindAMatrix calls AMBRE v2.1.1 to obtain the MB-representation corresponding to the
       given Feynman integral, and uses it to compute the \[ScriptCapitalA]-matrix.
"


FindTriangulations::usage="FindTriangulations[FindAMatrixOut]

This external module computes unimodular regular triangulations corresponding to the \[ScriptCapitalA]-matrix
generated by FindAMatrix using TOPCOM. Below, we provide details about the input arguments for
FindTriangulations.

   \[Bullet] FindAMatrixOut: Result returned by FindAMatrix.
   \[Bullet] Options:
       \[Dash] MaxRegularTriangs: This option can take either of the two values: \!\(\*
StyleBox[\"All\",\nFontSlant->\"Italic\"]\), or some
         positive integer. Its default value is \!\(\*
StyleBox[\"All\",\nFontSlant->\"Italic\"]\). When set to \!\(\*
StyleBox[\"All\",\nFontSlant->\"Italic\"]\), FindTriangulations
         tries to find all possible regular triangulations. When set to a positive integer \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\),
         FindTriangulations stops after obtaining upto \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) regular triangulations and then scans
         for unimodular regular triangulations.
       \[Dash] PrintRegularTriangs: This option accepts a boolean value. By default, this option is
         set to False. When set to True, FindTriangulations prints the regular triangulations
         in addition to the unimodular regular triangulations.
       \[Dash] RunInParallel: This option accepts a boolean value. By default, this option is set to
         False. When set to True, Mathematica\[CloseCurlyQuote]s native parallelization features are used.
       \[Dash] Docker: This option accepts a boolean value. By default, this option is set to False.
         When set to True, one can call TOPCOM from a Docker container having the name
         \"topcom\", to obtain the regular triangulations. This option might come in handy, should
         one fail to install TOPCOM natively on their system."


SeriesRepresentation::usage="SeriesRepresentation[Triangulations, TriangNum]

or,

SeriesRepresentation[Ideals, IdealNum]

where, the input arguments are as follows:

   \[Bullet] Triangulations: Result returned by FindTriangulations.
   \[Bullet] TriangNum: Serial number of the unimodular regular triangulation for which the correspond-
     ing series solution is to be derived
   \[Bullet] Ideals: Result returned by FindInitialIdeals.
   \[Bullet] IdealNum: Serial number of the square-free initial ideal for which the corresponding series
     solution is to be derived.
   \[Bullet] Options:
       \[Dash] SubstituteScales: This option accepts a boolean value. By default, this option is set
         to True. When set to True, all the indeterminate generic coefficients \!\(\*SubscriptBox[\(\[ScriptZ]\), \(i\)]\) , are substituted
         with their appropriate kinematic counterparts while constructing the series solution for
         the given non-generic Feynman integral. When False, this substitution is not done.
       \[Dash] ParameterValue: This option accepts a list of parameter substitutions.
         By default, this option is assigned an empty list."


GetClosedForm::usage="GetClosedForm[MySeries]

which has the following input arguments:

   \[Bullet] MySeries: Result returned by SeriesRepresentation.
   \[Bullet] Options:
       \[Dash] ParameterValue: This option accepts a list of parameter substitutions.
         By default, this option is assigned an empty list."


NumericalSum::usage="NumericalSum[MySeries, SubstitutionRules, SumLim]

with the following input arguments:

   \[Bullet] MySeries: Result returned by the SeriesRepresentation or GroebnerDeformation.
   \[Bullet] SubstitutionRules: This a list to substitute numerical values to parameters and scales 
     of MySeries before numerical summation.
   \[Bullet] SumLim: The upper-limit for summing over the summation variables. The same upper-limit
     is mainatined for each summation variable.
   \[Bullet] Options:
       \[Dash] NumericalPrecision: This option accepts a positive integer.
         It is used to set the precision of the numerical summation. By default,
         this option is set to MachinePrecision.
       \[Dash] RunInParallel: This option accepts a boolean value. By default, this option is set to
         False. When set to True, Mathematica\[CloseCurlyQuote]s native parallelization features are used.
       \[Dash] Docker: This option accepts a boolean value. By default, this option is set to False."


(* ::Section::Closed:: *)
(*External Modules Usage of Groebner Deformation Method*)


FindInitialIdeals::usage="FindInitialIdeals[FindAMatrixOut]

This external module generates all possible square-free initial ideals corresponding to the
\[ScriptCapitalA]-matrix generated by FindAMatrix. Below, we provide details about its input arguments.

   \[Bullet] FindAMatrixOut: Result returned by FindAMatrix."


GroebnerDeformation::usage="GroebnerDeformation[FindAMatrixOut]

with the following input arguments:

   \[Bullet] FindAMatrixOut: result returned by FindAMatrix.
   \[Bullet] Options:
       \[Dash] InitialIdeal: Serial number of the square-free initial ideal for which the corresponding
         series solution is to be derived. Its default value is False.
       \[Dash] Weight: This option accepts a list of non-negative integers, whose length is same as the
         number of columns of the \[ScriptCapitalA]-matrix. Its default value is False.
       \[Dash] AllInitialIdeals: This option accepts a boolean value. Its default value is False.
         When set to True, this module yields series solutions for all the possible square-free
         initial ideals sequentially.
       \[Dash] ParameterValue: This option accepts a list of parameter substitutions. By default,
         this option is assigned an empty list."


TriangulationToIdeal::usage="TriangulationToIdeal[Triangulations, TriangNum]

where, the input arguments are as follows:

   \[Bullet] Triangulations: Result returned by FindTriangulations.
   \[Bullet] TriangNum: Serial number of the unimodular regular triangulation for which the correspond-
     ing square-free initial ideal is to be derived."


IdealToTriangulation::usage="IdealToTriangulation[Ideals, IdealNum]

where, the input arguments are as follows:

   \[Bullet] Ideals: Result returned by FindInitialIdeals.
   \[Bullet] IdealNum: Serial number of the square-free initial ideal for which the corresponding unimod-
     ular regular triangulation is to be derived.
"


(* ::Section::Closed:: *)
(*Usage of Options*)


UseMB::usage = "This is an option of FindAMatrix, which accepts a boolean value. Its default value is False. When set True,
       FindAMatrix calls AMBRE v2.1.1 to obtain the MB-representation corresponding to the
       given Feynman integral, and uses it to compute the \[ScriptCapitalA]-matrix."

NumericalPrecision::usage = "This is an option of NumericalSum, which accepts a positive integer.
         It is used to set the precision of the numerical summation. By default,
         this option is set to MachinePrecision."

RunInParallel::usage = "This is an option of FindTriangulations and NumericalSum, which accepts a boolean value.
          By default, this option is set to False. When set to True, Mathematica\[CloseCurlyQuote]s native parallelization features are used.";

Docker::usage="This is an option of FindTriangulations, which accepts a boolean value. By default, this option is set to False.
         When set to True, one can call TOPCOM from a Docker container having the name
         \"topcom\", to obtain the regular triangulations. This option might come in handy, should
         one fail to install TOPCOM natively on their system.";

MaxRegularTriangs::usage="This is an option of FindTriangulations, which can take either of the two values: \!\(\*
StyleBox[\"All\",\nFontSlant->\"Italic\"]\), or some
         positive integer. Its default value is \!\(\*
StyleBox[\"All\",\nFontSlant->\"Italic\"]\). When set to All, FindTriangulations
         tries to find all possible regular triangulations. When set to a positive integer \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\),
         FindTriangulations stops after obtaining upto \!\(\*
StyleBox[\"n\",\nFontSlant->\"Italic\"]\) regular triangulations and then scans
         for unimodular regular triangulations.";

PrintRegularTriangs::usage="This is an option of FindTriangulations, which accepts a boolean value. By default, this option is
         set to False. When set to True, FindTriangulations prints the regular triangulations
         in addition to the unimodular regular triangulations.";

SubstituteScales::usage="This is an option of FindTriangulations, which accepts a boolean value. By default, this option is set
         to True. When set to True, all the indeterminate generic coefficients \!\(\*SubscriptBox[\(\[ScriptZ]\), \(i\)]\) , are substituted
         with their appropriate kinematic counterparts while constructing the series solution for
         the given non-generic Feynman integral. When False, this substitution is not done.";

ParameterValue::usage="This is an option of FindTriangulations and GroebnerDeformation, which accepts a
         list of parameter substitutions. By default, this option is assigned an empty list.";

InitialIdeal::usage="This is an option of GroebnerDeformation, which accepts the serial number of the
         square-free initial ideal for which the corresponding series solution is to be derived. Its default value is False.";

Weight::usage="This is an option of GroebnerDeformation, which accepts a list of non-negative integers, 
         whose length is same as the number of columns of the \[ScriptCapitalA]-matrix. Its default value is False."; 

AllInitialIdeals::usage="This is an option of GroebnerDeformation, which accepts a boolean value. Its default value is False.
         When set to True, this module yields series solutions for all the possible square-free
         initial ideals sequentially.";  


(* ::Section::Closed:: *)
(*Triangulation Method*)


Begin["Private`"]


(* ::Subsection::Closed:: *)
(*Setting Paths*)


If[!ValueQ@(Global`FeynGKZPath),Global`FeynGKZPath=NotebookDirectory[]];


If[!ValueQ@(Global`TOPCOMPath),Global`TOPCOMPath="/usr/local/bin"];
GKZGeom`topcomPath=Global`TOPCOMPath;


If[!ValueQ@(Global`PolyMakePath),Global`PolyMakePath="/usr/bin"];


(* ::Subsection::Closed:: *)
(*Constructing the Symanzik polynomials (Written by A. Smirnov)*)


UF[xx_, yy_, z_] := Module[{degree, coeff, i, t2, t1, t0, zz},
    zz = Map[Rationalize[##,0]&, z, {0, Infinity}];
    degree = -Sum[yy[[i]]*Global`x[i], {i, 1, Length[yy]}];
    coeff = 1;
    For[i = 1, i <= Length[xx], i++,
        t2 = Coefficient[degree, xx[[i]], 2];
        t1 = Coefficient[degree, xx[[i]], 1];
        t0 = Coefficient[degree, xx[[i]], 0];
        coeff = coeff*t2;
        degree = Together[t0 - ((t1^2)/(4 t2))];
    ];
    degree = Together[-coeff*degree] //. zz;
    coeff = Together[coeff] //. zz;
    {coeff, Expand[degree], Length[xx]}
];


(* ::Subsection:: *)
(*Finding the A - matrix*)


(* ::Subsubsection::Closed:: *)
(*Preparation  A - matrix from the Lee - Pomeransky polynomial*)


Amatrix[poly_,var_List]:=Module[{},

Return[{Join[{Table[1,{i,1,Length[#]}]},Transpose[#[[All,1]]]],#[[All,2]]}
&@Sort[CoefficientRules[Expand[poly],var],Lexicographic]]];


(* ::Subsubsection::Closed:: *)
(*Preparation  A - matrix from the Mellin - Barnes representation*)


findVar[expr_,var_]:=Module[{temp},temp=Hold[expr]/. var->0;
If[temp===Hold[expr],Nothing,var]];


findMBMatrix[MBIn_]:=Module[{A,IdentityA,NumDen=MBIn[[1]],IntVar=MBIn[[2]],NumCof,MBFold},MBFold=Length@IntVar;
NumCof=Table[Coefficient[NumDen[[i]],IntVar],{i,1,Length@NumDen}];
IdentityA=IdentityMatrix[(Length@NumDen)];
A=ArrayFlatten[{{NumCof,IdentityA}}];
Return[A]];


findA[MBOut_]:=Module[{MBList,MBListDen,MBListNum,MBVar,MBIntVar,MBNum,MBDen,Num,
Den,NumDen,NumDenTrimmed,MBMatIn,A,MBListNumFactors,MBListDenFactors,IntVar,Prefactor,MBScales,ConstantNum={},
ConstantDen={},PowerNum={},PowerDen={},RemovePos,CoDim},

MBList=List@@(MBOut);
MBListDen=Denominator[#]&/@MBList;
MBListNum=Numerator[#]&/@MBList;

MBListNumFactors=(FactorList[#])&/@MBListNum//Flatten//DeleteDuplicates;
MBListDenFactors=(FactorList[#])&/@MBListDen//Flatten//DeleteDuplicates;

MBListNumFactors=Table[ConstantArray@@#&/@FactorList[i]//Flatten,{i,MBListNum}]//Flatten;
MBListDenFactors=Table[ConstantArray@@#&/@FactorList[i]//Flatten,{i,MBListDen}]//Flatten;

IntVar=ToExpression@(("z"<>ToString@#)&/@(Range@100));

MBIntVar=findVar[MBOut,#]&/@IntVar;
Print[Style["Obtained an MB representation of ",Blue],Length@MBIntVar,Style[" fold.",Blue]];
If[Length@MBIntVar===0,Print[Style["As MB representation is of 0-fold no \[ScriptCapitalA]-matrix can be associated to it.",Red]];Abort[];];
ConstantNum={};
ConstantDen={};
PowerNum={};
PowerDen={};
Do[If[And@@(FreeQ[i,#]&/@MBIntVar),AppendTo[ConstantNum,i],If[Head@i===Power,AppendTo[PowerNum,i]]],{i,MBListNumFactors}];
Do[If[And@@(FreeQ[i,#]&/@MBIntVar),AppendTo[ConstantDen,i],If[Head@i===Power,AppendTo[PowerDen,i]]],{i,MBListDenFactors}];
Prefactor=Times@@ConstantNum/Times@@ConstantDen;
MBScales=Table[Times@@(Select[PowerNum,!FreeQ[#,MBIntVar[[i]]]&])/Times@@(Select[PowerDen,!FreeQ[#,MBIntVar[[i]]]&])/. {MBIntVar[[i]]->1},{i,Length@MBIntVar}]//Flatten;
Print[Style["The scales of the MB representation are ",Blue],MBScales,"."];

If[Length[Select[MBScales,NumberQ]]>0,Print[Style["The package cannot find the GKZ system for this MB yet.",Red]];Abort[];];

MBNum=Delete[#,0]&/@(Select[MBListNumFactors,Head[#]==Gamma&]);
MBDen=Delete[#,0]&/@(Select[MBListDenFactors,Head[#]==Gamma&]);
Num=Table[If[!And@@(FreeQ[i,#]&/@MBIntVar),i,Nothing],{i,MBNum}];
Den=Table[If[!And@@(FreeQ[i,#]&/@MBIntVar),i,Nothing],{i,MBDen}];

NumDen=Join[Num,-Den];
(*NumDenTrimmed=DeleteElements[NumDen,1->(-MBIntVar)];*)

RemovePos=Table[Last@Position[NumDen,i,1],{i,-MBIntVar}];
NumDenTrimmed=Delete[NumDen,RemovePos];

If[(Length@NumDen-Length@NumDenTrimmed)===Length@MBIntVar,Nothing,Print[" Some Issues! "];Abort[]];
MBMatIn=Append[{NumDenTrimmed},MBIntVar];
A=findMBMatrix@MBMatIn;

CoDim = (Length@(Transpose@A)-Length@A );
Print[Style["The associated \[ScriptCapitalA]-matrix \[Rule] ",Blue],A//MatrixForm,Style[", which has codim = ", Blue],CoDim,Style[".",Blue]];
Return[{Transpose@A,MBScales,MBIntVar,Prefactor,Num,Den}]];


(* ::Subsubsection::Closed:: *)
(*Interfacing with PolyMake (Inspired from a private notebook of Ren\[EAcute] P.Klausen)*)


CalcPolytopeVol[Amat_,OptionsPattern[{PolymakePath->Global`PolyMakePath}]]:=Module[{NormEuclVol},

Off[CreateFile::eexist];
SetDirectory[NotebookDirectory[]];
CreateFile["AforPOLYMAKE.dat"];

FileData=StringReplace[ToString[Amat[[1]]],{"}, {"->"\n","{{"->"","}}"->"",","->""}];
Export["AforPOLYMAKE.dat",FileData,OverwriteTarget->True];

Export["polytopevol.dat","use application \"polytope\";
open(INPUT, \"< AforPOLYMAKE.dat\"); 
my $points=new Matrix(<INPUT>);
close(INPUT);
my $polytope = new Polytope(POINTS=>$points); 
my $normvol = $polytope->LATTICE_VOLUME;
print $normvol;
exit();"];
RenameFile["polytopevol.dat","polytopevol.perl",OverwriteTarget->True];

polymakescript="\""<>NotebookDirectory[]<>"polytopevol.perl\"";

NormEuclVol=RunProcess[$SystemShell,"StandardOutput",OptionValue[PolymakePath]<>"/polymake --script "<>polymakescript];

Print[Style["Normalized Volume of the associated Newton Polytope \[Rule] ",Blue],NormEuclVol];
Return[NormEuclVol];
];


(* ::Subsubsection::Closed:: *)
(*External Module*)


Options[FindAMatrix]={UseMB->False};
 FindAMatrix[Standardform_,OptionsPattern[]]:=Module[{input,UFform, sympols, var, replacements, G, Amat, genAmat, Atransp,
 mom, prop, kinsub,MBout,FindAReturn,findAReturn,LoopNum,MBOut,IntVarSub1,IntVarSub2,MBVarChange,PropagatorPowers,PrefactorCorrection,
 UFFormat=False,TimeTaken,CoDim,Invariants=Standardform[[3]],PropPowers,ReturnValue},

TimeTaken=AbsoluteTiming[

Dim=Standardform[[4]];

Which[
ListQ@Standardform[[2]],

PropPowers=#[[3]]&/@(Standardform[[1]]);
UFform=Range[3];
UFform[[1]]=Standardform[[2]];
LoopNum=Length@UFform[[1]];
UFform[[2]]=Table[-(First@Standardform[[1]][[i]])^2+Part[Standardform[[1]][[i]],2]^2,{i,Length@Standardform[[1]]}];
UFform[[3]]=Standardform[[3]];

{mom,prop,kinsub}=UFform;

sympols=UF[mom,prop,kinsub];
replacements=Table[Global`x[i]->Subscript[Global`x, i],{i,Length@DeleteDuplicates@Cases[sympols[[1]],_Symbol[_Integer],\[Infinity]]}];
sympols=sympols/.replacements/.Invariants;
sympols=Expand@sympols/.Invariants;

,!ListQ@Standardform[[2]],
PropPowers=(Standardform[[1]])[[3]];
UFFormat=True;
LoopNum=Standardform[[2]];
input=Standardform;
sympols=(Standardform[[1]])[[{1,2}]];
sympols=sympols/.Invariants;
sympols=Expand@(Expand@sympols/.Invariants);
];

G=Total[sympols[[{1,2}]]];

Print[Style["The Symanzik polynomials \[Rule] U = ",Blue],Style[sympols[[1]]],Style[", F = ",Blue],Style[sympols[[2]]]];
Print[Style["The Lee-Pomeransky polynomial \[Rule] G = ",Blue],Style[G]];


Which[OptionValue[UseMB]===False

,

var=DeleteDuplicates@Cases[sympols[[1]],Subscript[_Symbol, _Integer],\[Infinity]];
Global`CoeffSubList=Table[Sort[CoefficientRules[Expand[G],var],Lexicographic][[i]][[2]],{i,Length[Sort[CoefficientRules[Expand[G],var],Lexicographic]]}];

genAmat=Amatrix[G,DeleteDuplicates@Cases[sympols[[1]],Subscript[_Symbol, _Integer],\[Infinity]]];
Atransp=genAmat[[1]];
Amat=Transpose@Atransp;

CoDim = (Length@(Transpose@Atransp)-Length@Atransp);
Print[Style["The associated \[ScriptCapitalA]-matrix \[Rule] ",Blue],Atransp//MatrixForm,Style[", which has codim = ", Blue],CoDim,Style[".",Blue]];


FindAReturn={Amat,OptionValue@UseMB};

, OptionValue[UseMB]===True,

SetDirectory[Global`FeynGKZPath];

Block[{Print},Get["AMBREv2.1.1.m"]//Quiet]; 
If[UFFormat,Print[Style["To use MB, please provide the momentum-representation of the Feynman integral.",Red]];Abort[]];

MBVarChange=ToExpression@((("AMBRE`z" <> ToString@#) <>"->" <> ("z" <> ToString@#)) & /@ (Range@100));
prop=Times@@(PR@@#&/@Standardform[[1]]);
LoopNum=Length@Standardform[[2]];
d=Standardform[[4]];
invariants=Standardform[[3]];
PropagatorPowers=#[[3]]&/@Standardform[[1]];
PrefactorCorrection=Times @@ ((-1)^-PropagatorPowers);

Block[{Print},MBOut=MBrepr[{Standardform[[5]]},{prop},Standardform[[2]]][[1]];];

MBOut=(MBOut*PrefactorCorrection)/.MBVarChange;

Print[Style["The Mellin-Barnes representation \[Rule] ",Blue],MBOut];
findAReturn=findA@MBOut;
FindAReturn=Append[findAReturn,OptionValue@UseMB];
];

If[!OptionValue@UseMB,
CalcPolytopeVol[FindAReturn]];

];

Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

ReturnValue=Insert[FindAReturn,LoopNum,-2];
ReturnValue=Insert[ReturnValue,PropPowers,-2];
Return[ReturnValue];

];


(* ::Subsection::Closed:: *)
(*Finding Triangulations*)


(* ::Subsubsection::Closed:: *)
(*Finding Regular Triangulations*)


findRegularTriangulations[Amat_,OptionsPattern[{UseDocker->False, TopcomPath->Global`TOPCOMPath,
Triangulations->AllPossible, DoInParallel->False, RegTriangs->False}]]:= Module[{Count,ShellInput,Atri,List1,List2,
List3,List4={},RegPrintStatus},
Off[CreateFile::eexist];
SetDirectory[NotebookDirectory[]];

RegPrintStatus=OptionValue@RegTriangs;

While[Length@List4===0,


CreateFile["AforTOPCOM.dat"];
Export["AforTOPCOM.dat",ToString@Amat];


Which[OptionValue[UseDocker]===False

,Block[{Print},RunProcess[$SystemShell,"StandardOutput",
"tr \'{}\' \'\[\]\' < \""<>NotebookDirectory[]<>"AforTOPCOM.dat\" | tee \""<>NotebookDirectory[]<>"AforTOPCOM.dat\""
];
];

If[Head[OptionValue[Triangulations]]===Integer,
Count=ToString@OptionValue[Triangulations];
(*Print["Finding upto "<>Count<>" regular triangulations"];*)

Which[StringTake[$OperatingSystem,3]==="Mac"

,RunProcess[$SystemShell,"StandardOutput","export PATH=\""<>OptionValue[TopcomPath]<>":$PATH\" && points2triangs --regular --affine < \""<>NotebookDirectory[]<>"AforTOPCOM.dat\" | head -n "<>Count<>" > \""<>NotebookDirectory[]<>"Atri.txt\""];

,StringTake[$OperatingSystem,3]==="Uni"

,ShellInput="export PATH=\""<>OptionValue[TopcomPath]<>":$PATH\" && points2triangs --regular --affine < "<>NotebookDirectory[]<>"AforTOPCOM.dat | head -n "<>Count<>" > "<>NotebookDirectory[]<>"Atri.txt";
Export["RunTopcom.txt",ShellInput,OverwriteTarget->True];
RenameFile["RunTopcom.txt","RunTopcom.sh",OverwriteTarget->True];
Run["sh RunTopcom.sh"];
];

,(*Print["Finding all regular triangulations"];*)

Block[{Print},RunProcess[$SystemShell,"StandardOutput","export PATH=\""<>OptionValue[TopcomPath]<>":$PATH\" && points2triangs --regular --affine < \""<>NotebookDirectory[]<>"AforTOPCOM.dat\" | tee \""<>NotebookDirectory[]<>"Atri.txt\""];];
];

Atri=Import[NotebookDirectory[]<>"Atri.txt"];

,OptionValue[UseDocker]===True

,Block[{Print},RunProcess[$SystemShell,"StandardOutput",
"export PATH=\"/usr/local/bin:$PATH\" && 
docker cp \""<>NotebookDirectory[]<>"/AforTOPCOM.dat\" topcom:/home && 
docker exec topcom sh -c \"tr \'{}\' \'\[\]\' < AforTOPCOM.dat | tee AforTOPCOM.dat\""
];
];

If[Head[OptionValue[Triangulations]]===Integer,
Count=ToString@OptionValue[Triangulations];
(*Print["Finding upto "<>Count<>" regular triangulations"];*)

Block[{Print},RunProcess[$SystemShell,"StandardOutput","export PATH=\"/usr/local/bin:$PATH\" && docker exec topcom sh -c \"points2triangs --regular --affine < AforTOPCOM.dat | head -n "<>Count<>" > Atri.txt\""];];,
(*Print["Finding all regular triangulations"];*)
Block[{Print},RunProcess[$SystemShell,"StandardOutput","export PATH=\"/usr/local/bin:$PATH\" && docker exec topcom sh -c \"points2triangs --regular --affine < AforTOPCOM.dat | tee Atri.txt\""];];
];

Atri=RunProcess[$SystemShell,"StandardOutput","export PATH=\"/usr/local/bin:$PATH\" && docker exec topcom sh -c \"cat Atri.txt\""];
RunProcess[$SystemShell,"StandardOutput"," export PATH=\"/usr/local/bin:$PATH\" && docker exec topcom sh -c \"rm *.dat *.txt\""];
];

List1=Map[First,StringPosition[Atri,":"]]+1;
List2=Map[First,StringPosition[Atri,";"]]-2;
List3=Table[{List1[[2 i]],List2[[i]]},{i,Length@List2}];
Which[
OptionValue[DoInParallel]===False
,
List4=ToExpression@(StringJoin[StringPart[Atri,Range[Sequence@@#]]]&/@List3)+1;
,
OptionValue[DoInParallel]===True
,
List4=ToExpression[ParallelMap[StringJoin[StringPart[Atri,Range[Sequence@@#]]]&,List3]]+1;
];
List4=Sort[List4,Length[#1]<Length[#2]&];

];


If[Length@List4!=0,

If[Head[OptionValue[Triangulations]]===Integer
,Print[Style["Finding upto ",Blue],OptionValue[Triangulations],Style[" regular triangulations ...",Blue]]
,Print[Style["Finding all regular triangulations ... ",Blue]];
];];

Count=0;



(*If[OptionValue@RegTriangs, Do[Print[Style[++Count,Bold]," :: ",i],{i,List4}]];*)

Return[List4]
];


(* ::Subsubsection::Closed:: *)
(*Finding Unimodular Regular Triangulations*)


findUnimodularRegularTriangulations[A_,AllTri_,\[Delta]_,RegPrintStatus_]:=
Module[{Count=0,DetList,AUT},

AUT={};

Do[DetList=Abs[Det[A[[#]]]]/\[Delta]&/@i; If[ContainsOnly[DetList,{1}],AppendTo[AUT,i](*,Print["Could not find any unimodular triangulation"]*)],{i,AllTri}];

AUT=Sort[AUT,Length[#1]<Length[#2]&];

If[AUT!={}

,

Print[Style["Found ",Blue],Length@AllTri,Style[" Regular Triangulations, out of which ",Blue],Length@AUT,Style[" are Unimodular.",Blue]];

If[RegPrintStatus,

Print[Style["The ",Blue],Length@AllTri,Style[" Regular Triangulations \[Rule] ",Blue]]; 

Do[Print[Style[++Count,Bold]," :: ",i],{i,AllTri}]];

Print[Style["The ",Blue],Length@AUT,Style[" Unimodular Regular Triangulations \[Rule] ",Blue]];



Count=0;

Do[Print[Style[++Count,Bold]," :: ",i],{i,AUT}];
Return@AUT;

,
Print[Style["Could not find any Unimodular Regular Triangulation. Please extend the range of Regular Triangulations to be computed if possible.",Red]];
Abort[];];];


(* ::Subsubsection::Closed:: *)
(*External Module*)


Options[FindTriangulations]={Docker->False,MaxRegularTriangs->All,RunInParallel->False,PrintRegularTriangs->False};
FindTriangulations[findAOut_,OptionsPattern[]]:=
Module[{minors,RegTri,Amat=findAOut[[1]],UniTri,\[Delta],FindTriOut,TimeTaken},

TimeTaken=AbsoluteTiming[

RegTri=findRegularTriangulations[Amat,UseDocker->OptionValue@Docker,Triangulations->OptionValue@MaxRegularTriangs, DoInParallel->OptionValue@RunInParallel,RegTriangs->OptionValue@PrintRegularTriangs];
minors=DeleteCases[Minors[Transpose@Amat,Length@Transpose@Amat][[1]],0];
\[Delta]=GCD[#]&@@minors;
UniTri=findUnimodularRegularTriangulations[Amat,RegTri,\[Delta],OptionValue@PrintRegularTriangs];
FindTriOut=Prepend[findAOut,UniTri];

];
Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

Return[FindTriOut];
];


(* ::Subsection:: *)
(*Finding Series Solutions*)


(* ::Subsubsection::Closed:: *)
(*Internal Module*)


Kvm = KeyValueMap[If[#, 
   Times @@ Power @@@ #2, 
   KeyValueMap[(Times @@ #2)^# &] @ 
      GroupBy[#2, #[[1, 2]] &, Map[#[[1, 1]]^#[[2]] &]]] &];
GroupByExponents[exp_] := Module[{fl = FactorList @ PowerExpand @ exp},Times @@ Prepend[Power @@ First[fl]] @Flatten[Kvm @ GroupBy[Rest @ fl, NumericQ @ #[[1, 1]] &]]];


(* ::Subsubsection::Closed:: *)
(*External Module*)


Options[SeriesRepresentation]={SubstituteScales->True,ParameterValue->{}};
SeriesRepresentation[findTriangulationOut_,TriangulationNum_Integer,OptionsPattern[]]:=
Module[{AUT=findTriangulationOut[[1]],Amat=findTriangulationOut[[2]],zsubs,fl,Argument,ExpNum,ExpDenom,Summand,
exp,UT,s,sb,As,Asb,M1,M2,Fac1,Fac2,Fac3,PochRes1,PochRes2,SerRes,Res,
Scales,Prefactor,MBUsed=Last@findTriangulationOut,MBScales,MBIntVar,Prefac,MBNum,MBDen,NumLen,DenLen,UTComplement,
UTDenoFree,MBFold,RowNum,ColNum,MBIntSolve,
FactorialFunc,MBNumComplement,MBNumSub,MBDenSub,MBNumDenSub,
MBIntSol, NewScales, SumVarCof, ScaleFactor, ConstantFactor,MBIntSolConstant,LoopNum,SumVar,SumPar,
minors,\[Delta],ReplacementRules=Rationalize[OptionValue@ParameterValue],TimeTaken,PropPowers=findTriangulationOut[[4]],a},

TimeTaken=AbsoluteTiming[

minors=DeleteCases[Minors[Transpose@Amat,Length@Transpose@Amat][[1]],0];
\[Delta]=GCD[#]&@@minors;

Which[
TriangulationNum <= Length@AUT 
, 
UT=AUT[[TriangulationNum]]; 
Summand={};
Res={};
,TriangulationNum > Length@AUT
,
Print[Style["Error! Given serial number of triangulation has exceeded the total number of triangulations found.",Red]];
Abort[];];

Print[Style["Unimodular Triangulation \[Rule] ",Blue],TriangulationNum];

If[MBUsed,
{MBScales,MBIntVar,Prefac,MBNum,MBDen,LoopNum}=findTriangulationOut[[3;;8]];

NumLen=Length@MBNum;
DenLen=Length@MBDen;
MBFold=Length@MBIntVar;
SumVar=Subscript[n, #]&/@(Range@MBFold);
FactorialFunc=Product[1/Gamma[1+i],{i,SumVar}];

Print[Style["Number of summation variables \[Rule] ",Blue],Length@SumVar];


UTComplement=Complement[Range@(NumLen+DenLen), #] & /@ UT;
UTDenoFree=Select[UTComplement, ContainsOnly[#, Range@NumLen] &];

Do[

MBIntSolve=Solve[MBNum[[i]]==-SumVar,MBIntVar]//Flatten;
MBNumComplement=Complement[Range@NumLen,i];
MBNumSub=MBNum[[MBNumComplement]]/.MBIntSolve//Expand;
MBDenSub=MBDen/.MBIntSolve//Expand;

MBIntSol=MBIntVar/.MBIntSolve;
NewScales=Table[SumVarCof=Coefficient[MBIntSol,i];-Times@@(MBScales^SumVarCof),{i,(SumVar)}];

ScaleFactor=Times@@(NewScales^(SumVar));
MBIntSolConstant=MBIntSol/.({#->0}&/@(SumVar)//Flatten)//Expand;
ConstantFactor=Times@@(MBScales^MBIntSolConstant);

MBNumDenSub=Prefac*ConstantFactor*ScaleFactor*FactorialFunc*Times@@(Gamma[#]&/@MBNumSub)/Times@@(Gamma[#]&/@MBDenSub);

AppendTo[Res,MBNumDenSub];


,{i,UTDenoFree}]


, (* If MB not used *)
LoopNum=findTriangulationOut[[3]];
fl={};
ColNum=Length@Amat;
RowNum=Length@(Transpose@Amat);
exp=Join[{Subscript[a, 0]},PropPowers];

zsubs=Table[Subscript[\[ScriptZ], i],{i,ColNum}];
SumPar=Subscript[\[ScriptZ], #]&/@Range@ColNum;

Which[RowNum==ColNum

,UT=AUT;
Argument=(Inverse@Transpose@Amat . exp);
ExpNum=Times@@Gamma[Argument];
ExpDenom=Abs[Det[Amat]]/\[Delta];
Res=ExpNum/ExpDenom Times@@(zsubs^-Argument);
Res={Res};

Print[Style["No summation involved.",Blue]];
,RowNum>ColNum

,Print[Style["Incorrect \[ScriptCapitalA]-matrix. Please make sure that the number or rows doesn't exceed the number of columns. ",Red]];

,RowNum<ColNum

,Res={};
Summand={};

Do[
s=UT[[j]];
sb=Complement[Range@ColNum,s];
SumVar=Subscript[n, #]&/@Range[Length@sb];
As=Amat[[s]];
Asb=Amat[[sb]];
M1=Inverse@Transpose@As; 
M2=M1 . Transpose@Asb;
Fac1=Times@@((SumPar[[s]])^-M1 . exp);
Fac2=Times@@(Gamma[#]&/@(M1 . exp+M2 . SumVar));
Fac3=Times@@((SumPar[[sb]])^SumVar)/Times@@((-SumPar[[s]])^(M2 . SumVar));
AppendTo[fl,FactorList @ PowerExpand @ Fac3];
Fac3=GroupByExponents@Fac3;
AppendTo[Summand,(Fac1*Fac2*Fac3)/Times@@(Gamma[1+#]&/@SumVar)];
,{j,Length@UT}];

AppendTo[Res,Summand];


Print[Style["Number of summation variables \[Rule] ",Blue],Length@SumVar];
];



(*Now let's put back the prefactor that we had ignored earlier*)
Prefactor=1/(Gamma[(LoopNum+1)Subscript[a, 0]-Total@DeleteCases[exp,Subscript[a, 0]]]Times@@Gamma@DeleteCases[exp,Subscript[a, 0]]);
Res= Prefactor*Res;
Res=Res/.ReplacementRules/.{Subscript[a, 0]-> Dim/2};
If[OptionValue@SubstituteScales,
zsubs=Table[SumPar[[i]]->Global`CoeffSubList[[i]],{i,Length@Global`CoeffSubList}];
Print[Style["Non-generic limit \[Rule] ",Blue],zsubs];
Scales=DeleteDuplicates@Flatten@Table[Kvm[GroupBy[Rest @ fl[[i]], NumericQ @ #[[1, 1]] &]][[2]]/.{Power[x_,y_]:>x},{i,Length@fl}];



Res=Res/.zsubs/.ReplacementRules,

Print[Style["We use generic scales denoted by ",Blue],zsubs];];

];

Res=Expand//@Res;

Print[Style["The series solution is the sum of following ",Blue],Length@Flatten[Res//Simplify],Style[" terms.",Blue]];

Table[Print[Style["Term ",Bold],i," :: \n",Flatten[Res][[i]]],{i,Length@Flatten[Res]}];

];

Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

Return[{Flatten[Res//Simplify],Length@SumVar}];
];


Options[GetClosedForm]={ParameterValue->{}};
GetClosedForm[Ser_,OptionsPattern[]]:=Module[{SerRes,PochRes1,PochRes2,SerRep=Ser[[1]],NumSum=Ser[[2]],
SumVar=Subscript[n, #]&/@Range[Ser[[2]]],SubstitutionRules=OptionValue@ParameterValue,TimeTaken,a},

TimeTaken=AbsoluteTiming[

Which[NumSum==0,

SerRes=SerRep/.SubstitutionRules;
Print[Style["Solution involves no summation. ",Blue]];
Print[Style["Solution \[Rule] ",Blue],SerRes[[1]]];
,

NumSum===1,

{
SerRes=Sum[#,{Subscript[n, 1],0,Infinity}]&/@SerRep;
SerRes=SerRes/.SubstitutionRules;
Print[Style["Closed form found! ",Blue]];

Table[Print[Style["Term ",Bold],i," :: \n",SerRes[[i]]],{i,Length@SerRes}];
}
,

NumSum===2,

{
PochRes1=SerRep/.{Subscript[a, 0] -> Dim/2}//.Olsson`gammatoPoch[SumVar]; 
PochRes2=Olsson`Olsson[1,SumVar,#,Olsson`sim->True]&/@PochRes1;
SerRes=Olsson`serrecog2var[SumVar,#/.Pochhammer[1,m_]->m!]&/@PochRes2;
SerRes=SerRes/.SubstitutionRules;
Print[Style["Closed form found with Olsson! ",Blue]];
(*Print[SerRes];*)
Table[Print[Style["Term ",Bold],i," :: \n",SerRes[[i]]],{i,Length@SerRes}];
},

NumSum>=3,

{
SerRes=SerRes/.SubstitutionRules;
Print[Style["No closed form could be found using this package. ",Red]];}
];

];

Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

Return[SerRes/.SubstitutionRules;];
];


(* ::Subsection:: *)
(*Finding Numerical Result*)


(* ::Subsubsection::Closed:: *)
(*External Module*)


Options[NumericalSum]={NumericalPrecision->MachinePrecision,RunInParallel->False};
NumericalSum[Ser_,ParamSub_,Lim_,OptionsPattern[]]:=
Module[{SerRep=Ser[[1]],NumSum=Ser[[2]],SumLim,SumCommand,SumToList,SeriesSub,NumRes={},TimeTaken,a,
ParamSubRationalized=Rationalize@ParamSub,ReturnNumericalVal},

If[!IntegerQ@NumSum,Print[Style["Input series not in correct format!",Red]];Abort[];];

TimeTaken=AbsoluteTiming[

SeriesSub=SerRep/.{Subscript[a, 0]->(Global`d0-2 Global`\[Epsilon])/2}/.ParamSubRationalized;

Which[
NumSum===0,
SumCommand=N,
OptionValue[RunInParallel]===False,
SumCommand=Sum;Off[General::munfl];
Off[General::stop],

OptionValue[RunInParallel]===True,
SumCommand=ParallelSum;
ParallelEvaluate[Off[General::munfl]];
ParallelEvaluate[Off[General::stop]];

];
 
SumLim=Table[{Subscript[n, i],0,Lim},{i,NumSum}];

Table[
With[{Summand=SeriesSub[[j]]},
NumRes=Insert[NumRes,SumCommand[Summand,Evaluate[Sequence@@SumLim]],-1]]
,{j,Length@SeriesSub}];

Print[Style["Numerical result = ",Blue],N[Total@NumRes,OptionValue[NumericalPrecision]]];

ReturnNumericalVal=N[NumRes,OptionValue[NumericalPrecision]];
];


Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

Return[ReturnNumericalVal];
];


(* ::Section:: *)
(*Groebner Deformation Method*)


(* ::Subsection::Closed:: *)
(*Setting Default Directories*)


templatepath=NotebookDirectory[]<>"templates/";
outputpath=NotebookDirectory[];


(* ::Subsection::Closed:: *)
(*Generating Temporary Files*)


(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];
If[DirectoryQ["templates"],
SetDirectory[NotebookDirectory[]<>"templates"],
TemplatesLocation=CreateDirectory["templates"];
SetDirectory[TemplatesLocation];];

File1="template_Amat.txt";
File2="template_gbw.txt";
File3="template_gfan.txt";
File4="template_indw.txt";
File5="template_intersection_ideals2.txt";
File6="template_intersection_of_ideals.txt";
File7="template_primary_decomposition.txt";
File8="template_stdpair.txt";
File9="template_toricideal.txt";

String1="
A1 = matrix `Amatrix`




\"`path`outputs/kernel.txt\" << toString ker A1 << close

quit()
";
String2="loadPackage \"Dmodules\";
D =  QQ[`var`];

var = `var`
weight = `weight`
givenid = `givenid`





Dideal=ideal`givenid`;
groeb=gbw(Dideal,`weight`);



\"`path`outputs/gbw.txt\" << toString groeb<< close

quit()
";
String3="R=QQ[dx_1..dx_`l`];

toric = `M2toric`

loadPackage(\"gfanInterface\",Reload=>true);





\"`path`outputs/gfan.txt\" << toString gfan toric << close

quit()";

String4="w = `weight`
A = `Amatrix`


loadPackage \"Dmodules\";
R = QQ[x_1..x_(#A_0)]
D= makeWA R
IA=`toricIdealA`;
indw = toString inw(IA,w) 
\"`path`outputs/indw.txt\" << indw << close

quit()";
String5="
`line1`




\"`path`outputs/intersection_ideal2.txt\" << toString `line2` << close

quit()
";
String6="
A1 = `Amatrix`


R=ZZ[t_1..t_(#A1_0)];

l = `ideals`



\"`path`outputs/intersection_ideal.txt\" << toString intersect l << close


quit()";
String7="
`line1`




\"`path`outputs/primary_decomposition.txt\" << toString `line2` << close

quit()
";
String8="A = `Amatrix`


R = ZZ[dx_1..dx_(#A_0)]
Iinw = `indw`
stdpair =  standardPairs Iinw 
stdpair2=for i from 0 to length(stdpair)-1 list (if stdpair#i#0===1 then stdpair#i else {exponents(stdpair#i#0),stdpair#i#1})
\"`path`outputs/stdpair.txt\" << toString stdpair2 << close

quit()

";
String9="A = matrix`Amatrix`
A1 = `Amatrix`

loadPackage \"Quasidegrees\";
R=QQ[dx_1..dx_(#A1_0)];



\"`path`outputs/toricideal.txt\" << toString toricIdeal(A,R) << close


quit()";
Export[File1,String1];Export[File2,String2];Export[File3,String3];Export[File4,String4];Export[File5,String5];
Export[File6,String6];Export[File7,String7];Export[File7,String7];Export[File8,String8];Export[File9,String9];



SetDirectory[Global`FeynGKZPath]


(* ::Subsection::Closed:: *)
(*Internal Modules*)


M2PrimaryDecomposition[Amat_,ideal_]:=Module[{t0,t3,l,p},
p=Length[Amat[[1]]];
l=ToExpression[#]&/@("x"<>ToString[#]&/@Range[p]);
(*Print[l];*)
t0= FileTemplate[templatepath<>"template_primary_decomposition.txt"];
t3=TemplateApply[t0,<| "line1"-> "R = QQ[x_1 .. x_"<>ToString[p]<>"]","path"-> ToString[outputpath],"line2"->"primaryDecomposition(ideal"<>StringReplace[ToString[StringReplace[ToString[Table["x_"<>ToString[iii],{iii,#}]]&/@ideal,{"{"-> "(","}"-> ")",","-> "*"}]],{"{"-> "(","}"-> ")"}]<>")"|>];
Export[outputpath<>"outputs/primary_decompositionforM2.txt",ToString[t3]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/primary_decompositionforM2.txt"];
(*Print["M2 o/p : ", Import[outputpath<>"outputs/intersection_ideal2.txt"]];*)
Return[ToExpression[StringReplace[StringDelete[Import[outputpath<>"outputs/primary_decomposition.txt"],{"ideal"}],{"x_"-> "x","("-> "{",")"-> "}"}]]/.Table[l[[i]]-> Subscript[Global`x, i],{i,1,Length[l]}]/.Subscript[x_,i_]-> i]
(*Return[Times@@@(Subscript[t, #1]&/@ToExpression[StringReplace[StringSplit[ToString[#]],"t"\[Rule] ""]]
&/@ToExpression[StringReplace[StringDelete[ Import[NotebookDirectory[]<>"outputs/intersection_ideal.txt"],"ideal"],{"t_"\[Rule] "t","("\[Rule]"{",")"\[Rule] "}" }]])]*)]


M2intersectionideals2[Amat_,ideals_]:=Module[{t0,t3,l,p},
p=Length[Amat[[1]]];
l=ToExpression[#]&/@("x"<>ToString[#]&/@Range[p]);
(*Print[l];*)
t0= FileTemplate[templatepath<>"template_intersection_ideals2.txt"];
t3=TemplateApply[t0,<| "line1"-> "R = QQ[x_1 .. x_"<>ToString[p]<>"]","path"-> ToString[outputpath],"line2"->"intersect"<>StringReplace[ToString["ideal"<>#&/@(ToString[Table["x_"<>ToString[iii],{iii,#}]]&/@ideals)],{"{"-> "(","}"-> ")"}]|>];
Export[outputpath<>"outputs/intersection_of_ideals2forM2.txt",ToString[t3]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/intersection_of_ideals2forM2.txt"];
(*Print["M2 o/p : ", Import[outputpath<>"outputs/intersection_ideal2.txt"]];*)
Return[ToExpression[StringReplace[StringDelete[Import[outputpath<>"outputs/intersection_ideal2.txt"],{"ideal"}],{"x_"-> "x","("-> "{",")"-> "}"}]]/.Table[l[[i]]-> Subscript[Global`x, i],{i,1,Length[l]}]]
(*Return[Times@@@(Subscript[t, #1]&/@ToExpression[StringReplace[StringSplit[ToString[#]],"t"\[Rule] ""]]
&/@ToExpression[StringReplace[StringDelete[ Import[NotebookDirectory[]<>"outputs/intersection_ideal.txt"],"ideal"],{"t_"\[Rule] "t","("\[Rule]"{",")"\[Rule] "}" }]])]*)]


M2toricideal[Amat_]:= Module[{t0,t1,l},

(* given a matrix Amat, it finds the toric ideal of the matrix*)

l=ToExpression[#]&/@("x"<>ToString[#]&/@ Range[Length[Amat[[1]]]]);
t0= FileTemplate[templatepath<>"template_toricideal.txt"];
    t1=TemplateApply[t0,<| "Amatrix"-> ToString[Amat],"path"-> ToString[outputpath]|>];
Export[outputpath<>"outputs/toricidealforM2.txt",ToString[t1]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/toricidealforM2.txt"];
(*Print["M2toricideal o/p : ",Import[outputpath<>"outputs/toricideal.txt"]];*)
Return[ToExpression[StringReplace[StringDelete[Import[outputpath<>"outputs/toricideal.txt"],{"ideal"}],{"dx_"-> "x","("-> "{",")"-> "}"}]]/.Table[l[[i]]-> Subscript[Global`t, i],{i,1,Length[l]}]]]


M2gfan[Amat_]:= Module[{toric,t0,t1,l},

(*given a matrix Amat, it finds all the possible initial ideal of the toric
ideal of the given matrix
it uses M2toricideal. The o/p is of the form 
{{{toric ideal},{expression of toric ideal}},
{{initial Ideal 1},{expression of GB 1}}
...
{{initial Ideal n},{expression of GB n}}
}

*)

l=ToExpression[#]&/@("x"<>ToString[#]&/@ Range[Length[Amat[[1]]]]);
toric=M2toricideal[Amat];
t0= FileTemplate[templatepath<>"template_gfan.txt"];
t1=TemplateApply[t0,<| "l"-> ToString[Length[l]],"M2toric"-> Import[outputpath<>"outputs/toricideal.txt"],"path"-> ToString[outputpath]|>];
Export[outputpath<>"outputs/gfanforM2.txt",ToString[t1]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/gfanforM2.txt"];
(*Print["M2gfan o/p : ",Import[outputpath<>"outputs/gfan.txt"]];*)
Return[{{{"toric ideal "},toric},
toinitialideal[Import[outputpath<>"outputs/gfan.txt"]]/.Table[l[[i]]-> Subscript[Global`t, i],{i,1,Length[l]}]}]]


toinitialideal[new_String]:=Module[{new2,new3},new2=(StringSplit[#]<>"}"&/@StringSplit[StringDrop[StringDrop[StringReplace[new,{"dx_"->"x"}],1],-1],"},"]);
new3=StringCases[#,"("~~___~~")"]&/@(StringSplit[#,","]&/@new2);
Return[Table[{ToExpression[Flatten[new3[[i]]]],ToExpression[If[i===Length[new2],StringDrop[new2[[i]],-1],new2[[i]]]]},{i,1,Length[new2]}]]]


squarefreeQ[Amat_,gfan_]:=Module[{toric,initials,var,pos,table},
(* returns the initial ideals that are squrefree

The o/p is of the form 
{{{toric ideal},{expression of toric ideal}},
{{initial Ideal 1},{expression of GB 1}}
...
{{initial Ideal n},{expression of GB n}}
}

*)
var=Table[Subscript[Global`t, i],{i,1,Length[Amat[[1]]]}];
(*Print[var];*)
{toric,initials}=gfan;
(*Print[initials[[All,1]]];*)
table=Table[Select[DeleteDuplicates[Flatten[CoefficientRules[#,var][[1,1]]&/@(initials[[All,1]][[i]])]],#>=2&],{i,1,Length[initials[[All,1]]]}];
pos=Flatten[Position[table,{}]];
Return[{toric,initials[[pos]]}]
]


inequalities[list_,w_]:=Module[{int,gb,allint,allgb,pos,sign,lead, other,aa,ineq={}},
(*var=Variables[list];
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[var]}]];*)
{int,gb}=list;
allint=int[[All,1,1]];
allgb=gb[[All,All,1]];
(*Print[allint];
Print[allgb];*)
Table[pos = Flatten[Position[allgb[[i]],allint[[i]]]];(*Print[pos];*)lead=allgb[[i,Flatten[pos]]][[1]];other=Complement[allgb[[i]],{lead}];
(*Print["lead",lead];
Print["other",other];*)
aa = lead- Plus@@other;(*Print[aa];*)ineq=AppendTo[ineq,aa . w>=0];,{i,1,Length[int]}];
Return[ineq]]


weightvectorcondition[Amat_,gfan_]:=Module[{gfanop=gfan[[2]],coeff,weight={},w,var,in,inlist={}},

(*given Amat and gfan (may/may not be squarefree) it finds the conditions on the weight vectors*)

(*var=Variables[gfanop];*)
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[Amat[[1]]]}]];
coeff=CoefficientRules[#,Table[Subscript[Global`t, i],{i,1,Length[Amat[[1]]]}]]&/@gfan[[2,All]];

Table[in=inequalities[coeff[[i]],w];inlist=AppendTo[inlist,in];,{i,1,Length[coeff]}];
Return[inlist]]


M2kernelofAmat[Amat_]:=Module[{t0,t3},
(* given a Amat, it finds the kernal of the Amat using M2
similar Mathematica command is NullSpace*)

t0= FileTemplate[templatepath<>"template_Amat.txt"];
t3=TemplateApply[t0,<| "Amatrix"-> ToString[Amat],"path"-> ToString[outputpath]|>];
Export[outputpath<>"outputs/kerforM2.txt",ToString[t3]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/kerforM2.txt"];
(*Print["M2ker o/p : ", Import[outputpath<>"outputs/kernel.txt"]];*)
Return[ToExpression[StringDelete[Import[outputpath<>"outputs/kernel.txt"],"image matrix"]]//Transpose]]


Options[weightvector]={kernel-> "automatic"};
weightvector[Amat_,gfan_,OptionsPattern[]]:=Module[{w,inlist,weight={},var,ker},
(*not giving the proper weight vectors as
the elements of the vectors should be positive integers*)
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[Amat[[1]]]}]];
If[OptionValue[kernel]==="automatic",Print["Finding kernel automatically"];ker=M2kernelofAmat[Amat];,ker=OptionValue[kernel];];
(*ker=OptionValue[kernel];Print[ker];*)
(*Print["kernel: ",ker];*)
inlist=weightvectorcondition[Amat,gfan];
Table[weight=AppendTo[weight,w/.Flatten[FindInstance[Join[inlist[[i]],(#>=0)&/@w,{w . ker[[1]]>0}],w,Integers]]],{i,1,Length[inlist]}];
Return[weight]]


selectweight[weights_]:=Module[{},
Return[Flatten[Position[MemberQ[#,_Integer]&/@weights,True]]]
]


M2stdpair[Amat_,initial_]:=Module[{t0,t3,l},
l=ToExpression[#]&/@("x"<>ToString[#]&/@ Range[Length[Amat[[1]]]]);
t0= FileTemplate[templatepath<>"template_stdpair.txt"];
t3=TemplateApply[t0,<| "Amatrix"-> ToString[Amat],"path"-> ToString[outputpath],"indw"->StringReplace[StringDelete[ToString[FortranForm[initial/.Subscript[Global`t, m_]-> Global`dx[m]]],{")"}],{"List"-> "monomialIdeal","dx("-> "dx_"}]<>")"|>];
Export[outputpath<>"outputs/stdpairforM2.txt",ToString[t3]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/stdpairforM2.txt"];
(*Print["M2stdpair o/p : ", Import[outputpath<>"outputs/stdpair.txt"]];*)
Return[ToExpression[StringReplace[Import[outputpath<>"outputs/stdpair.txt"],"dx_"-> ""]]]]


Toidealsfromstdpairs[Amat_,stdpair0_]:=Module[{var,stdpair2,ideals,string,stdpair},
If[Length[stdpair0]===1,stdpair={stdpair0[[1]],stdpair0[[1]]},stdpair=stdpair0];
(*var=Table[Subscript[Global`t, i],{i,1,Length[A[[1]]]}];*)
stdpair2={Flatten[#[[1]]],Complement[Range[Length[Amat[[1]]]],#[[2]]]}&/@stdpair;
(*Print[stdpair2];*)
ideals=Table[Subscript[Global`t,stdpair2[[i]][[2]][[j]]]-stdpair2[[i]][[1]][[stdpair2[[i]][[2]][[j]]]],{i,1,Length[stdpair2]},{j,1,Length[stdpair2[[i]][[2]]]}];
string=StringReplace[ToString[StringReplace[ToString[#],{"{"-> "ideal(","}"-> ")"}]&/@(ideals/.Subscript[Global`t, a_]:>  "t_"<>ToString[a])],{"{"-> "(","}"-> ")"}];
Return[StringDelete[string,Whitespace]
]]


M2initialideal[Amat_,weight_]:=Module[{t0,t2,l},
l=ToExpression[#]&/@("x"<>ToString[#]&/@ Range[Length[Amat[[1]]]]);
t0= FileTemplate[templatepath<>"template_indw.txt"];
t2=TemplateApply[t0,<| "Amatrix"-> ToString[Amat],"path"-> ToString[outputpath],"weight"-> ToString[Join[-weight,weight]],"toricIdealA"->Import[outputpath<>"/outputs/toricideal.txt"]|>];
Export[outputpath<>"outputs/indwforM2.txt",ToString[t2]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/indwforM2.txt"];
(*Print["M2initialideal o/p : ", Import[outputpath<>"outputs/indw.txt"]];*)
Return[ToExpression[StringReplace[StringDelete[Import[outputpath<>"outputs/indw.txt"],{"ideal"}],{"dx_"-> "x","("-> "{",")"-> "}"}]]/.Table[l[[i]]-> Subscript[Global`t, i],{i,1,Length[l]}]]]


M2intersectionideals[Amat_,stdpair_]:=Module[{t0,t3,l},
l=ToExpression[#]&/@("x"<>ToString[#]&/@ Range[Length[Amat[[1]]]]);
t0= FileTemplate[templatepath<>"template_intersection_of_ideals.txt"];
t3=TemplateApply[t0,<| "Amatrix"-> ToString[Amat],"path"-> ToString[outputpath],"ideals"->Toidealsfromstdpairs[Amat,stdpair]|>];
Export[outputpath<>"outputs/intersection_of_idealsforM2.txt",ToString[t3]];
Run["/usr/bin/"<>"M2 "<>StringReplace[ToString[outputpath],Whitespace:>  "\\ "]<>"outputs/intersection_of_idealsforM2.txt"];
(*Print["M2 o/p : ", Import[outputpath<>"outputs/intersection_ideal.txt"]];*)
Return[ToExpression[StringReplace[StringDelete[Import[outputpath<>"outputs/intersection_ideal.txt"],{"ideal"}],{"t_"-> "x","("-> "{",")"-> "}"}]]/.Table[l[[i]]-> Subscript[Global`t, i],{i,1,Length[l]}]]
(*Return[Times@@@(Subscript[t, #1]&/@ToExpression[StringReplace[StringSplit[ToString[#]],"t"\[Rule] ""]]
&/@ToExpression[StringReplace[StringDelete[ Import[NotebookDirectory[]<>"outputs/intersection_ideal.txt"],"ideal"],{"t_"\[Rule] "t","("\[Rule]"{",")"\[Rule] "}" }]])]*)]


(* ::Subsection::Closed:: *)
(*Other commands*)


inequalities[list_,w_]:=Module[{int,gb,allint,allgb,pos,sign,lead, other,aa,ineq={}},
(*var=Variables[list];
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[var]}]];*)
{int,gb}=list;
allint=int[[All,1,1]];
allgb=gb[[All,All,1]];
(*Print[allint];
Print[allgb];*)
Table[pos = Flatten[Position[allgb[[i]],allint[[i]]]];(*Print[pos];*)lead=allgb[[i,Flatten[pos]]][[1]];other=Complement[allgb[[i]],{lead}];
(*Print["lead",lead];
Print["other",other];*)
aa = lead- Plus@@other;(*Print[aa];*)ineq=AppendTo[ineq,aa . w>=0];,{i,1,Length[int]}];
Return[ineq]]


Options[weightvector2]={kernel-> "automatic"};
weightvector2[Amat_,gfan_,OptionsPattern[]]:=Module[{w,inlist,weight={},var,ker},
(*not giving the proper weight vectors as
the elements of the vectors should be positive integers*)
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[Amat[[1]]]}]];
If[OptionValue[kernel]==="automatic",Print["Finding kernel automatically"];ker=M2kernelofAmat[Amat];,ker=OptionValue[kernel];];
(*ker=OptionValue[kernel];Print[ker];*)
(*Print["kernel: ",ker];*)
inlist=weightvectorcondition2[Amat,gfan];
(*Print[inlist];*)
weight=AppendTo[weight,w/.Flatten[FindInstance[Join[inlist,(#>=0)&/@w,{w . ker[[1]]>0}],w,Integers]]];
Return[weight]]


weightvectorcondition2[Amat_,initialideal_]:=Module[{gfanop=initialideal,coeff,weight={},w,var,in,inlist={}},

(*given Amat and gfan (may/may not be squarefree) it finds the conditions on the weight vectors*)

(*var=Variables[gfanop];*)
w=ToExpression[Table["w"<>ToString[i],{i,1,Length[Amat[[1]]]}]];
coeff=CoefficientRules[#,Table[Subscript[Global`t, i],{i,1,Length[Amat[[1]]]}]]&@initialideal;
(*Print[coeff];*)

in=inequalities[coeff,w];

Return[in]]


roots[Amat_,para_,indideal_(*from Macaulay2, given as a list*)]:=Module[{leftideal,th,fakeindideal,rts},
(*If[MatrixQ[Amat],,Print["A is not a matrix"];Abort[];];*)
th=Table[Subscript[Global`t, i],{i,1,Length[Amat[[1]]]}];
leftideal=Amat . th-para;
(*Print[leftideal];*)
fakeindideal=Join[leftideal,If[Head[indideal]===List,indideal,{indideal}]];
(*Print[(#\[Equal]0)&/@fakeindideal];*)
rts=#[[All,2]]&/@Solve[#==0&/@fakeindideal,th];
Return[rts]]


psim3[index_]:=Flatten[Table[Pochhammer[a_,index[[i]] (a1_/;IntegerQ[a1]&&a1<0)]-> (-1)^(-index[[i]] a1)/Pochhammer[1-a,- a1  index[[i]]],{i,1,Length[index]}]];


sim1[index_]:=Flatten[Table[{Gamma[y_.(x_. index[[i]]+a_)]->   Pochhammer[y a,y x index[[i]]]Gamma[y a],Pochhammer[ x_.(z_. index[[i]]+a:_:0),n___]->   Pochhammer[  x a,n+x z  index[[i]]]/Pochhammer[x a,x z  index[[i]]]},{i,1,Length[index]}]];


bracket[v_List,w_List]:=Power[-1,Plus@@w]Times@@Pochhammer[-v,w]//.sim1[Variables[w]](*//.psim3[Variables[w]]*)(*,Element[Variables[w],Integers]&&And@@(#>0&/@Variables[w])]*)


upum[u_]:=Module[{up,um},
up=If[#1>0,#1,0]&/@#&/@u;
um=u-up;
Return[Transpose[{up,-um}]]]


series[index_,roots_,nullspace_]:=Module[{v,ns,soln,v1,v2},
v1=upum[nullspace];
(*Print[v1];*)
v2={Plus@@(index*v1[[All,1]]),Plus@@(index*v1[[All,2]])};
(*Print[v2];*)
v= Plus@@(index *nullspace);
(*Print[ Plus@@(index *nullspace)];*)
ns={#+ v,#} &/@roots;
(*Print[ns];*)
soln=Table[(#[[2]]/#[[1]])&@Table[bracket[ns[[j]][[i]], v2[[i]]],{i,1,2}] * Times@@Power[Table[Subscript[\[ScriptZ], i],{i,1,Length[v]}],ns[[All,1]][[j]]],{j,1,Length[ns]}];
Return[(*Sum[#,{n,0,\[Infinity]}]&/@(soln/.Pochhammer[1,m_]\[Rule] m!)*) soln]]


prefactor[para_,roots_]:=Module[{},Return[Table[Times@@Gamma[DeleteCases[-roots[[j]],0]]/Gamma[-para[[1]]],{j,1,Length[roots]}]]]


solution[Amat_,nullspace_,para_,indideal_,index_,scales_]:=Module[{rts,srs,pref},
If[Length[Amat]=!=Length[para],Print["wrong Matrix"];Abort[];];
rts=roots[Amat,para,indideal];
(*Print[rts];*)
srs=series[index,rts,nullspace]/.MapThread[Rule,{Table[Subscript[\[ScriptZ], i],{i,1,Length[Amat[[1]]]}],scales}];
pref=prefactor[para,rts];
Return[{pref,srs}]]


indexsimplification[exp_]:=Module[{select0,select1,oldvar,rules,newvar,replacement,exp1},
(*Print[FreeQ[exp,Pochhammer[0,___]]];*)
Return[If[FreeQ[exp,Pochhammer[0,___]]===False,select0=Cases[exp,Power[Pochhammer[0,___],x_.]]/.Power[z_,n_]-> z/.Pochhammer[0,z_]->z;
select1=Cases[exp,Power[Pochhammer[1,___],x_.]]/.Power[z_,n_]-> z/.Pochhammer[1,z_]->z;
(*Print[{select0,select1}];*)
oldvar=Variables[Join[select0,select1]];
newvar = Table[Subscript[Global`ppp, i],{i,1,Length[oldvar]}];
replacement=positivepoch[newvar];
(*Print[replacement];*)
exp1=exp/.Flatten[Solve[Join[MapThread[Equal,{select0,-newvar[[1;;Length[select0]]]}],MapThread[Equal,{select1,newvar[[Length[select0]+1;;-1]]}]],oldvar]]//.replacement/.Global`ppp-> n;
Assuming[Element[Table[Subscript[n, i],{i,1,Length[newvar]}],Integers]&&(#>=0&/@Table[Subscript[n, i],{i,1,Length[newvar]}]),
Refine[Simplify//@exp1]](*/.Pochhammer[z___,m_]-> Gamma[z+m]/Gamma[z]*),Simplify//@exp(*/.Pochhammer[z___,m_]-> Gamma[z+m]/Gamma[z]*)]]]


positivepoch[index_]:= Flatten[Prepend[{positivepoch2[index]},Flatten[Table[Pochhammer[a_,index[[i]] (a1_/;IntegerQ[a1]&&a1<0)]->   (-1)^(-index[[i]] a1)/Pochhammer[1-a,- a1  index[[i]]],{i,1,Length[index]}]]]];


positivepoch2[index_]:=Pochhammer[a_,Plus@@(index*(\!\(\*
TagBox[
StyleBox[
RowBox[{"PatternTest", "[", 
RowBox[{
RowBox[{"Pattern", "[", 
RowBox[{"#", ",", 
RowBox[{"Blank", "[", "]"}]}], "]"}], ",", 
RowBox[{"Function", "[", 
RowBox[{"And", "[", 
RowBox[{
RowBox[{"IntegerQ", "[", "#", "]"}], ",", 
RowBox[{"Less", "[", 
RowBox[{"#", ",", "0"}], "]"}]}], "]"}], "]"}]}], "]"}],
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\)&/@(ToExpression[#]&/@("a"<>ToString[#]&/@Range[Length[index]]))))]->  Power[-1,-Plus@@(index*(ToExpression[#1]&/@("a"<>ToString[#]&/@Range[Length[index]])))]/Pochhammer[1-a,-Plus@@(index*(ToExpression[#1]&/@("a"<>ToString[#]&/@Range[Length[index]])))]


positivepoch3[index_List]:=positivepoch2/@DeleteCases[Subsets[index],{}];


(* ::Subsection:: *)
(*External Modules*)


IdealToTriangulation[FindInitialOut_, IdealsNum_Integer] := 
 Module[{Amat = FindInitialOut[[1]], Ideals, p, pd, AllIdeals, 
   SelectedIdeal, ideal,MappedTriangulation,TimeTaken},
   
   TimeTaken=AbsoluteTiming[
   Ideals = Length@(FindInitialOut[[2, 2]]);
  AllIdeals = FindInitialOut[[2, 2, #, 1]] & /@ (Range@Ideals);
   If[IdealsNum>Length@AllIdeals,Print[Style["Error! Given serial number of initial ideal has exceeded the total number of initial ideals found.",Red]];Abort[]];
  
  p = Length[Amat[[1]]];
  
  SelectedIdeal = AllIdeals[[IdealsNum]];
  
  
  ideal = List @@ # & /@ SelectedIdeal;
  ideal = ideal /. {Subscript[Global`t, p_] :> p}; 
  pd = M2PrimaryDecomposition[Amat, ideal];
  MappedTriangulation=Sort[Complement[Range[p], #] & /@ pd];
  Print[Style["Initial Ideal ",Blue],SelectedIdeal,Style[" is mapped to the triangulation ",Blue],MappedTriangulation,Style[".",Blue]];];
  
  Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];
  Return[MappedTriangulation];
  ]


TriangulationToIdeal[TriangulationOut_, TriangulationNum_Integer] := 
 Module[{Amat=TriangulationOut[[2]]//Transpose, 
   AllTriangulation = TriangulationOut[[1]], ideal, p,
   SelectedTriangulation, MappedInitialIdeal,TimeTaken},
   
   TimeTaken=AbsoluteTiming[
   If[TriangulationNum>Length@AllTriangulation,Print[Style["Error! Given serial number of triangulation has exceeded the total number of triangulations found.",Red]];Abort[]];
  
  p = Length[Amat[[1]]];
  SelectedTriangulation = AllTriangulation[[TriangulationNum]];
  ideal = Complement[Range[p], #] & /@ SelectedTriangulation;
  
  MappedInitialIdeal = M2intersectionideals2[Amat, ideal];
  MappedInitialIdeal=MappedInitialIdeal/.{Global`x->Global`t};
  Print[Style["Triangulation ", Blue], SelectedTriangulation, 
   Style[" is mapped to the initial ideal ", Blue], 
   MappedInitialIdeal, Style[".", Blue]];];
   
   Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];
  Return[MappedInitialIdeal];
  ]


FindInitialIdeals[Amat1_]:=Module[{toric,sqfree,Amat=Amat1[[1]]//Transpose,loopnumber=Amat1[[2]],MBStatus=Last@Amat1,PropPowers=Amat1[[3]],TimeTaken},

TimeTaken=AbsoluteTiming[

If[SquareMatrixQ@Amat,Print[Style["The associated \[ScriptCapitalA]-matrix has codim=0 for which one has to perform a deformation manually as mentioned in arXiv:1907.00507 to find initial ideals.",Red]];
Print[Style["Switching to the Triangulation Approach.",Brown]];
Return[FindTriangulations[Amat1]];
];
toric=M2gfan[Amat];
sqfree=squarefreeQ[Amat,toric];
Print[Style["There are ",Blue],Length[sqfree[[2]][[All,1]]],Style[" possible square-free initial ideals :",Blue]];
Table[Print[Style[iii,Bold]," :: ", sqfree[[2]][[All,1]][[iii]]],{iii,1,Length[sqfree[[2]][[All,1]]]}];

];

Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];
Return[Join[{Amat},{sqfree},{loopnumber},{PropPowers},{MBStatus}]]];


SeriesRepresentation[{Amat_,sqfree_/;(!MatrixQ@sqfree),loopnumber_,PropPower_,MBStatus_},InitialIdealNo_Integer,OptionsPattern[]]:=Module[{scale,allsoln,allinitials,para,indices,soln,soln1,
soln2,t0,t1,t2,t3,stdpair,stdpair2,nullspace,toric,wtcondition,correspondingweight,
selectedweight,selectedinitial,indicial,pos,allinitialideals,prefac,SumVar,ScaleSub,TimeTaken,a,ParamSub=Rationalize[OptionValue@ParameterValue]},

TimeTaken=AbsoluteTiming[

If[MBStatus,
Print[Style["Deriving series representation using Gr\[ODoubleDot]bner deformation for a GKZ system derived from MB is not yet implemented.",Red]];
Print[Style["Please use the triangulation approach for this case.",Blue]];
Abort[];
];

If[InitialIdealNo> Length[sqfree[[2]]],Print[Style["Error! Given serial number of initial ideal has exceeded the total number of initial ideal found.",Red]];Abort[];];

Print[Style["Initial Ideal \[Rule] ",Blue],InitialIdealNo];

allinitialideals=sqfree[[2,All,1]];
toric=sqfree[[2,All,2]];

ClearAll[Global`x,Global`dx,Global`t];

para=Join[{-Subscript[a, 0]},-PropPower];


prefac=1/( Gamma[ (loopnumber + 1) Subscript[a, 0] - Plus@@PropPower] Times @@ Gamma[PropPower]);


If[OptionValue@SubstituteScales,scale = Global`CoeffSubList;
ScaleSub=Subscript[\[ScriptZ], #]->scale[[#]]&/@Range@(Length@Global`CoeffSubList);
,scale=Table[Subscript[\[ScriptZ], i],{i,Length@(Transpose@Amat)}]];


indices=Table[Subscript[n, i],{i,1,Length[Transpose[Amat]]-MatrixRank[Amat]}];
SumVar=indices;

If[FileExistsQ[outputpath<>"outputs"],DeleteDirectory[outputpath<>"outputs",DeleteContents->True];];
CreateDirectory[outputpath<>"outputs"];


nullspace=M2kernelofAmat[Amat];
correspondingweight=Flatten[weightvector2[Amat,{allinitialideals[[InitialIdealNo]],toric[[InitialIdealNo]]},kernel-> nullspace]];
selectedinitial = allinitialideals[[InitialIdealNo]];

If[(And@@NumericQ/@correspondingweight)===False,
nullspace=-nullspace;
correspondingweight=Flatten[weightvector2[Amat,{allinitialideals[[InitialIdealNo]],toric[[InitialIdealNo]]},kernel-> nullspace]];
selectedinitial = allinitialideals[[InitialIdealNo]];(*Print[{"here2",selectweight[allweights]}];*)];

stdpair=M2stdpair[Amat,selectedinitial];
indicial=M2intersectionideals[Amat,stdpair];
soln=solution[Amat,nullspace,para,indicial,indices,scale]//.positivepoch3[indices];
soln1={soln[[1]],indexsimplification/@(soln[[2]])}//.positivepoch3[indices];
soln2=Gamma[Subscript[a, 0]]*soln1[[1]]*soln1[[2]];


soln2=prefac*soln2/.(ParamSub)/.{Subscript[a, 0]-> Dim/2};

soln2=soln2/.{Pochhammer[r_,s_]:> Gamma[r+s]/Gamma[r]};
soln2=Expand//@soln2;

Print[Style["Number of summation variables \[Rule] ",Blue],Length@SumVar];
Print[Style["The series solution is the sum of following ",Blue],Length@Flatten[soln2],Style[" terms.",Blue]];

soln2=soln2/.(ParamSub);

If[OptionValue@SubstituteScales,Print[Style["Non-generic limit \[Rule] ",Blue],ScaleSub],Print[Style["We use generic scales denoted by ",Blue],scale]];

Table[Print[Style["Term ",Bold] ,Style[iii]," :: \n",soln2[[iii]]],{iii,1,Length[soln2]}];

];

Print[Style["Time Taken ",Blue],Style[TimeTaken[[1]],Black],Style[" seconds",Blue]];

Return[{soln2,Length@SumVar}];
]


Options[GroebnerDeformation]={InitialIdeal-> False,ParameterValue->{},Weight-> False(*,Scales -> False*),
AllInitialIdeals-> False(*, save-> NotebookDirectory[]*)};
GroebnerDeformation[AmatIn_,OptionsPattern[]]:=Module[{scale,allsoln,allinitials,para,indices,soln,soln1,soln2,
t0,t1,t2,t3,stdpair,stdpair2,nullspace,toric,sqfree,wtcondition,allweights,Amat=AmatIn[[1]] // Transpose,
selectedweight,selectedinitial,indicial,pos,PropPower=AmatIn[[3]],a,prefac,loopnumber = AmatIn[[2]],flag=0,
MBStatus=Last@AmatIn,TimeTaken},


If[MBStatus,
Print[Style["Deriving series representation using Gr\[ODoubleDot]bner Deformation for a GKZ system derived from MB is not yet implemented.",Red]];
Print[Style["Please use the triangulation approach for this case.",Blue]];
Abort[];
];

Which[
OptionValue[Weight]=!=False&&OptionValue[InitialIdeal]=!=False&&OptionValue[AllInitialIdeals]=!=False,
Print[Style["AllInitialIdeals can't be true when either Weight or InitialIdeal is specified.",Red]];Abort[],

OptionValue[Weight]=!=False&&OptionValue[AllInitialIdeals]=!=False,
Print[Style["AllInitialIdeals can't be true when either Weight or InitialIdeal is specified.",Red]];Abort[],

OptionValue[InitialIdeal]=!=False&&OptionValue[AllInitialIdeals]=!=False,
Print[Style["AllInitialIdeals can't be true when either Weight or InitialIdeal is specified.",Red]];Abort[],

OptionValue[Weight]=!=False&&OptionValue[InitialIdeal]=!=False,
Print[Style["Weight and InitialIdeal can not be called specified simultaneously.",Red]];Abort[]];


ClearAll[Global`x,Global`dx,Global`t];
(*para=Join[{Subscript[a, 0]},PropPower];
prefac=1/( Gamma[ (loopnumber + 1) Subscript[a, 0] - Plus@@PropPower] Times @@ Gamma[PropPower]);*)

para=Join[{-Subscript[a, 0]},-PropPower];


prefac=1/( Gamma[ (loopnumber + 1) Subscript[a, 0] - Plus@@PropPower] Times @@ Gamma[PropPower]);
scale = Global`CoeffSubList;
(*If[OptionValue@Scales,scale = Global`CoeffSubList;
(*scale=Subscript[\[ScriptZ], #]->scale[[#]]&/@Range@(Length@Global`CoeffSubList);*)
,scale=Table[Subscript[\[ScriptZ], i],{i,Length@(Transpose@Amat)}]];*)

(*Print[scale];*)
(*If[OptionValue[Scales]===False,scale=Table[Subscript[\[ScriptZ], i],{i,1,Length[Amat[[1]]]}],scale=OptionValue[Scales]];*)

indices=Table[Subscript[n, i],{i,1,Length[Transpose[Amat]]-MatrixRank[Amat]}];

(*outputpath=OptionValue[save];*)
If[FileExistsQ[outputpath<>"outputs"],DeleteDirectory[outputpath<>"outputs",DeleteContents->True];];
CreateDirectory[outputpath<>"outputs"];


toric=M2gfan[Amat];
sqfree=squarefreeQ[Amat,toric];
(*Print[Style["Total number of square-free initial ideals :: ",Blue],sqfree[[2,All,1]]//Length];*)


Which[




OptionValue[AllInitialIdeals],

(*For the option of allinitialideals*)
(*toric=M2gfan[Amat];*)
(*sqfree=squarefreeQ[Amat,toric];*)


allinitials={Amat,sqfree,AmatIn[[-3]],AmatIn[[-2]],AmatIn[[-1]]};

allsoln=Table[(*Print["\n",Style["Initial Ideal :: ",Blue],allinitials[[i]], "\n"];*)
SeriesRepresentation[allinitials, i,ParameterValue-> OptionValue[ParameterValue]]
(*GroebnerDeformation[AmatIn,InitialIdeal-> i,ParameterValue-> OptionValue[ParameterValue](*,Scales-> OptionValue[Scales]*)]*),{i,1,Length[sqfree[[2]]]}];
Return[allsoln];
,




(*no options are given. everything is done automatically*) 
OptionValue[Weight]===False&&OptionValue[InitialIdeal]===False,

(* 
1. the toric ideal and all the possible initial ideals are found.
2. the quare free monomial ideals are seperated out.
3. for each possible initial monomial ideal the conditions on 
the corresponding weight vector are found.
4. One such weight vector is seleceted that satisfy the condition
weightvector.kernel>0
5. the indicial ideal is found using the std pairs.
6. these are used as an argument in the solution submodule to find
the series solution

*)

(*toric=M2gfan[Amat];
sqfree=squarefreeQ[Amat,toric];*)
(*wtcondition=weightvectorcondition[Amat,sqfree];*)
(*If[OptionValue[kernel]===False,,nullspace=OptionValue[kernel];];*)
nullspace=M2kernelofAmat[Amat];
(*Print[{Amat,sqfree, nullspace}];*)
allweights=weightvector[Amat,sqfree,kernel-> nullspace];
selectedweight = selectweight[allweights];
(*Print["allweights: ",allweights];
Print["weight: ",allweights[[selectedweight]]];*)



If[OptionValue[InitialIdeal]===False,selectedinitial = sqfree[[2,First[selectedweight]]][[1]];,selectedinitial=OptionValue[InitialIdeal];];
Print["\n"];Print[Style["Possible initial ideals :: ",Blue],sqfree[[2,All,1]],"\n"];
Print[Style["Selected initial ideal :: ",Blue],selectedinitial,"\n"];
stdpair=M2stdpair[Amat,selectedinitial];
(*stdpair2=M2intersectionideals[Amat,stdpair];*)
(*Toidealsfromstdpairs[Amat,stdpair];*)
indicial=M2intersectionideals[Amat,stdpair];

,
OptionValue[Weight]=!=False&&OptionValue[InitialIdeal]===False,
If[And@@((#>=0&&IntegerQ[#])&/@OptionValue[Weight]),Nothing,Print[Style["Weight vector should have positive integer as its elements",Red]];Abort[];];
If[Length[OptionValue[Weight]]=!= Length[Amat[[1]]],Print[Style["The length of the weight vector should be "<>ToString[Length[Amat[[1]]]],Red]];Abort[];];


(* when weight vector is given, the initial ideal and the suitable kernel
can be found provided it is a good one.

1. first the toric ideal is calculated
2. The initial ideal wrt the given weight vector is found
3. we check if the initial ideal generated by the weight vector is
monomial ideal. if so then continue
4. kernel if found with the condition u.w>0
5. std pairs are found
6. indicial ideal are found 
These are used in the solution module to find the series solutions
 *)

(*toric=M2toricideal[Amat];*)
(*toric =toric[[1,2]];*)

selectedinitial = M2initialideal[Amat,OptionValue[Weight]];

If[Select[Flatten[DeleteDuplicates[Flatten[Flatten[CoefficientRules[#,Table[Subscript[Global`t, i],{i,1,Length[Amat[[1]]]}]]&/@selectedinitial][[All,1]]]]],#>=2&]==={},
Nothing,Print[Style["The weight vector is not generic",Red]];Abort[];];
Print[Style["Weight :: ",Blue],OptionValue@Weight];
Print[Style["Selected initial ideal :: ",Blue],selectedinitial];
nullspace=M2kernelofAmat[Amat];
If[OptionValue[Weight] . nullspace[[1]]<0,nullspace=-nullspace];
stdpair=M2stdpair[Amat,selectedinitial];
(*stdpair2=M2intersectionideals[Amat,stdpair];*)
(*Toidealsfromstdpairs[Amat,stdpair];*)
indicial=M2intersectionideals[Amat,stdpair];
,
OptionValue[Weight]===False&&OptionValue[InitialIdeal]=!=False,
(*
If the initial ideal is given then one has to find the suitable weight vector
and kernel

1. find all the possible initial ideal using M2gfan
2. find the squarefree ones
3. finf the kernel
4. find all the weight vectors for each of the initial ideals
5. find the position of the given initial ideal in the list of all possible 
initial ideals
6. select the corresponding weight and initial ideal
7. Find stdpair, indicial ideal

These are used in the solution module to find the series solutions
*)

If[NumberQ[OptionValue[InitialIdeal]]===False,Print[Style["The InitialIdeal should be an Integer",Red]];];
(*toric=M2gfan[Amat];*)

(*Print["toric:  ",toric];*)
(*sqfree=squarefreeQ[Amat,toric];*)
(*Print["sqfree:  ",sqfree];*)

If[OptionValue[InitialIdeal]> Length[sqfree[[2]]]||OptionValue[InitialIdeal]<1,Print[Style["There are "<>ToString[Length[sqfree[[2]]]]<>" square-free initial ideals",Red]];Abort[];];
(*wtcondition=weightvectorcondition[Amat,sqfree];*)
nullspace=M2kernelofAmat[Amat];
allweights=weightvector[Amat,sqfree,kernel-> nullspace];
(*Print["allweights: ",allweights];*)
(*pos=Flatten[Position[sqfree[[2;;-1]][[1]][[All,1]],OptionValue[initialideal]]];*)
pos={OptionValue[InitialIdeal]};
(*Print[{pos,ContainsAny[selectweight[allweights],pos]}];*)
If[ContainsAny[selectweight[allweights],pos],(*Print["y"];*)
selectedweight = selectweight[allweights];selectedinitial = sqfree[[2,First[pos]]][[1]];
(*Print[{"here",selectweight[allweights]}];*)
,
nullspace=-nullspace;allweights=weightvector[Amat,sqfree,kernel-> nullspace];selectedweight = selectweight[allweights];
selectedinitial = sqfree[[2,First[pos]]][[1]];(*Print[{"here2",selectweight[allweights]}];*)];
(*selectedweight = selectweight[allweights];*)
(*Print["select: ",selectweight[allweights]];
(*Print["allweights: ",allweights];*)*)
Print[Style["Kernel :: ",Blue],nullspace];
Print[Style["Selected weight vector :: ",Blue],allweights[[First[pos]]]];
Print[Style["Selected initial ideal :: ",Blue], Flatten[Position[sqfree[[2,All,1]],selectedinitial]]//First];


stdpair=M2stdpair[Amat,selectedinitial];

indicial=M2intersectionideals[Amat,stdpair];

,
OptionValue[Weight]===False&&OptionValue[InitialIdeal]===False&&OptionValue[AllInitialIdeals]===False,
Print[Style["Weight and InitialIdeal can not be called simultaneously",Red]];Abort[];];

soln=solution[Amat,nullspace,para,indicial,indices,scale]//.positivepoch3[indices];

soln1={soln[[1]],indexsimplification/@(soln[[2]])}//.positivepoch3[indices];
soln2=Gamma[Subscript[a, 0]]*soln1[[1]]*soln1[[2]];

soln2=prefac*soln2/.{Subscript[a, 0]-> Dim/2}/.(OptionValue@ParameterValue)(*If[OptionValue[ParameterValue]=!={},OptionValue[ParameterValue],Nothing]*);

soln2=soln2/.{Pochhammer[r_,s_]:> Gamma[r+s]/Gamma[r]};
soln2=Expand//@soln2;

Table[Print[Style["Term ",Blue],Style[iii,Bold]," :: \n",soln2[[iii]]],{iii,1,Length[soln2]}];


(*If[OptionValue[Weight]===False,
Table[Print[Style["Term ",Blue],Style[iii,Bold]," :: \n",soln2[[iii]]],{iii,1,Length[soln2]}];
,
Table[Print[Style["Term ",Blue],Style[iii,Bold]," :: \n",soln2[[iii]]],{iii,1,Length[soln2]}];];*)



Return[{soln2,Length@indices}]];


(* ::Section::Closed:: *)
(*End of package*)


End[]

EndPackage[]
